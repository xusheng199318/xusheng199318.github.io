---
title: 内存分配及回收策略
date: 2019-02-16 20:22:04
tags: JVM
---

![img](堆内存.png)

### 新生代

> 新生代分为`eden`区和2个`survivor`区，默认比例为8:1:1
>
> 可通过参数`-XX:SurvivorRatio=8`进行配置
>
> 默认大小为物理内存的 1/64
>
> 垃圾收集策略：**复制算法**

#### eden区

> 当我们使用`new`关键字创建对象的时候该对象被分配在堆内存中的新生代中的`eden`区中

#### survivor区

> 进行一些GC后仍存活的对象进入`survivor`区，`survivor`区默认有2块空间，s0和s1，有1块一直都为空

### 老年代

> 为新生代提供担保机制。当创建的对象无法在新生代分配时或在新生代经历多次GC（默认15次）后仍存活的对象会被分配到老年代

#### 大对象直接进入老年代

> 大对象：需要大量连续内存空间的对象，例如：长字符串和数组
>
> -XX：PretenureSizeThreshold=3145728（3M）当创建的对象大于该值时直接在老年代分配（该参数只对Serial和ParNew收集器有效）

~~~java
/**
 * -verbose:gc -Xms20M -Xmx20M -Xmn10M
 * -XX:+PrintGCDetails -XX:+UseParNewGC -XX:PretenureSizeThreshold=3145728
 */
public void testEden() {
    int m = 1024 * 1024;
    byte[] allocation;
    allocation = new byte[5 * m];
}
~~~

上述代码中将大于3M的对象直接分配到老年代

#### 长期存活的对象进入老年代

> 对象在`eden`中出生后且经过一次GC后且可以被`Survivor`容纳的话该对象的Age就为1，在`Survivor`中每经过一次GC该对象的Age就会+1，当它的Age到一定阈值（默认为15）后就晋升到老年代
>
> -XX：MaxTenuringThreshold=1 对象晋升老年代阈值

~~~java
/**
 * -verbose:gc -XX:+PrintGCDetails
 * -Xms20M -Xmx20M -Xmn10M -XX:+UseParNewGC
 * -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution
*/
public void testMaxTenuringThreshold() throws InterruptedException {
    int m = 1024 * 1024;
    byte[] allocation1, allocation2, allocation3;
    allocation1 = new byte[m / 4];
    allocation2 = new byte[4 * m];
    allocation3 = new byte[4 * m];
    allocation3 = null;
    allocation3 = new byte[4 * m];
}

~~~



